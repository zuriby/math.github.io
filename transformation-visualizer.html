<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Linear Algebra — 18.06</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #111; color: #fff; font-family: 'Georgia', serif; }
    
    table.matrix { border-collapse: collapse; margin: 0 4px; }
    table.matrix tr { height: 26px; }
    table.matrix td { padding: 4px 6px; font-family: monospace; font-size: 14px; text-align: left; vertical-align: middle; white-space: nowrap; }
    table.matrix td sub { font-size: 10px; vertical-align: baseline; position: relative; top: 2px; }
    table.matrix td.left-bracket { 
      border-left: 2px solid #888; 
      border-top: 2px solid #888; 
      border-bottom: 2px solid #888; 
      width: 6px; 
      padding: 4px 0;
    }
    table.matrix td.right-bracket { 
      border-right: 2px solid #888; 
      border-top: 2px solid #888; 
      border-bottom: 2px solid #888; 
      width: 6px; 
      padding: 4px 0;
    }
    table.matrix input {
      width: 28px;
      background: transparent;
      border: none;
      color: #fff;
      text-align: left;
      font-family: monospace;
      font-size: 14px;
      padding: 0;
      outline: none;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  
  <script type="text/babel">
    const { useState, useRef, useEffect, useMemo } = React;

    // ============== MATH UTILITIES ==============
    
    const createIdentityMatrix = (n) => {
      const m = [];
      for (let i = 0; i < n; i++) {
        const row = [];
        for (let j = 0; j < n; j++) {
          row.push(i === j ? 1 : 0);
        }
        m.push(row);
      }
      return m;
    };
    
    const createZeroVector = (n) => Array(n).fill(0);
    
    const matrixVectorMultiply = (A, x) => {
      const n = A.length;
      const result = [];
      for (let i = 0; i < n; i++) {
        let sum = 0;
        for (let j = 0; j < n; j++) {
          sum += A[i][j] * x[j];
        }
        result.push(sum);
      }
      return result;
    };
    
    const getColumn = (A, j) => A.map(row => row[j]);
    
    // Convert decimal to fraction string
    const toFraction = (decimal, tolerance = 1e-10) => {
      if (Number.isInteger(decimal)) return String(decimal);
      if (Math.abs(decimal) < tolerance) return '0';
      
      const sign = decimal < 0 ? '-' : '';
      const absDecimal = Math.abs(decimal);
      
      // Check common denominators
      const denominators = [2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 16, 20, 100];
      for (const d of denominators) {
        const n = Math.round(absDecimal * d);
        if (Math.abs(n / d - absDecimal) < tolerance) {
          // Simplify the fraction
          const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
          const g = gcd(n, d);
          const num = n / g;
          const den = d / g;
          if (den === 1) return sign + String(num);
          return sign + num + '/' + den;
        }
      }
      
      // Fall back to decimal if no nice fraction found
      return sign + absDecimal.toFixed(2);
    };
    
    // Compute rank of a matrix using row reduction
    const rank = (M) => {
      const m = M.map(row => [...row]); // copy
      const rows = m.length;
      const cols = m[0].length;
      let r = 0;
      
      for (let c = 0; c < cols && r < rows; c++) {
        // Find pivot
        let pivotRow = -1;
        for (let i = r; i < rows; i++) {
          if (Math.abs(m[i][c]) > 1e-10) {
            pivotRow = i;
            break;
          }
        }
        if (pivotRow === -1) continue;
        
        // Swap rows
        [m[r], m[pivotRow]] = [m[pivotRow], m[r]];
        
        // Eliminate below
        for (let i = r + 1; i < rows; i++) {
          const factor = m[i][c] / m[r][c];
          for (let j = c; j < cols; j++) {
            m[i][j] -= factor * m[r][j];
          }
        }
        r++;
      }
      return r;
    };
    
    // Check if system Ax = b is consistent (b in column space of A)
    const isConsistent = (A, b) => {
      const n = A.length;
      // Augmented matrix [A|b]
      const augmented = A.map((row, i) => [...row, b[i]]);
      const rankA = rank(A);
      const rankAug = rank(augmented);
      return rankA === rankAug;
    };
    
    // Compute null space basis (simplified - returns dimension)
    const nullity = (A) => {
      const n = A.length;
      return n - rank(A);
    };
    
    const scaleVector = (v, s) => v.map(x => x * s);
    
    const addVectors = (...vectors) => {
      const n = vectors[0].length;
      const result = Array(n).fill(0);
      for (const v of vectors) {
        for (let i = 0; i < n; i++) {
          result[i] += v[i];
        }
      }
      return result;
    };
    
    // Determinant (recursive, works for any n)
    const determinant = (M) => {
      const n = M.length;
      if (n === 1) return M[0][0];
      if (n === 2) return M[0][0] * M[1][1] - M[0][1] * M[1][0];
      
      let det = 0;
      for (let j = 0; j < n; j++) {
        const minor = M.slice(1).map(row => [...row.slice(0, j), ...row.slice(j + 1)]);
        det += Math.pow(-1, j) * M[0][j] * determinant(minor);
      }
      return det;
    };
    
    // Matrix inverse using Gauss-Jordan (returns null if singular)
    const inverse = (M) => {
      const n = M.length;
      const aug = M.map((row, i) => [...row, ...createIdentityMatrix(n)[i]]);
      
      for (let i = 0; i < n; i++) {
        // Find pivot
        let maxRow = i;
        for (let k = i + 1; k < n; k++) {
          if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) maxRow = k;
        }
        [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
        
        if (Math.abs(aug[i][i]) < 1e-10) return null;
        
        // Scale pivot row
        const scale = aug[i][i];
        for (let j = 0; j < 2 * n; j++) aug[i][j] /= scale;
        
        // Eliminate column
        for (let k = 0; k < n; k++) {
          if (k !== i) {
            const factor = aug[k][i];
            for (let j = 0; j < 2 * n; j++) aug[k][j] -= factor * aug[i][j];
          }
        }
      }
      
      return aug.map(row => row.slice(n));
    };
    
    // ============== UI COMPONENTS ==============
    
    const DimensionSelector = ({ value, onChange }) => (
      <div style={{ display: 'flex', gap: '4px', marginBottom: '20px' }}>
        {[2, 3, 4, 5].map(n => (
          <button
            key={n}
            onClick={() => onChange(n)}
            style={{
              padding: '8px 16px',
              background: value === n ? '#444' : '#222',
              border: '1px solid #444',
              color: value === n ? '#fff' : '#666',
              fontFamily: 'Georgia, serif',
              fontSize: '14px',
              cursor: 'pointer'
            }}
          >
            ℝ<sup>{n}</sup>
          </button>
        ))}
      </div>
    );
    
    const PictureToggle = ({ rowPicture, colPicture, onRowChange, onColChange }) => (
      <div style={{ display: 'flex', gap: '20px', marginBottom: '20px' }}>
        <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }}>
          <input
            type="checkbox"
            checked={rowPicture}
            onChange={(e) => onRowChange(e.target.checked)}
            style={{ accentColor: '#666' }}
          />
          <span style={{ fontFamily: 'monospace', fontSize: '12px', color: rowPicture ? '#fff' : '#666' }}>
            Row Picture
          </span>
        </label>
        <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }}>
          <input
            type="checkbox"
            checked={colPicture}
            onChange={(e) => onColChange(e.target.checked)}
            style={{ accentColor: '#666' }}
          />
          <span style={{ fontFamily: 'monospace', fontSize: '12px', color: colPicture ? '#fff' : '#666' }}>
            Column Picture
          </span>
        </label>
      </div>
    );
    
    const MatrixInput = ({ matrix, onChange }) => {
      const n = matrix.length;
      const m = matrix[0].length;
      return (
        <table className="matrix">
          <tbody>
            {matrix.map((row, i) => (
              <tr key={i}>
                {i === 0 && <td className="left-bracket" rowSpan={n}></td>}
                {row.map((val, j) => (
                  <td key={j}>
                    <input
                      type="number"
                      value={val}
                      onChange={(e) => {
                        const newMatrix = matrix.map(r => [...r]);
                        newMatrix[i][j] = parseInt(e.target.value) || 0;
                        onChange(newMatrix);
                      }}
                    />
                  </td>
                ))}
                {i === 0 && <td className="right-bracket" rowSpan={n}></td>}
              </tr>
            ))}
          </tbody>
        </table>
      );
    };
    
    const MatrixDisplay = ({ matrix }) => {
      if (!matrix || matrix.length === 0) return null;
      const n = matrix.length;
      return (
        <table className="matrix">
          <tbody>
            {matrix.map((row, i) => (
              <tr key={i}>
                {i === 0 && <td className="left-bracket" rowSpan={n}></td>}
                {row.map((val, j) => (
                  <td key={j} style={{ color: '#ccc' }}>
                    {typeof val === 'number' ? toFraction(val) : val}
                  </td>
                ))}
                {i === 0 && <td className="right-bracket" rowSpan={n}></td>}
              </tr>
            ))}
          </tbody>
        </table>
      );
    };
    
    

    // ============== BLACKBOARD COMPONENT ==============
    
    const SymbolicVector = ({ prefix, n }) => (
      <table className="matrix">
        <tbody>
          {Array.from({ length: n }, (_, i) => (
            <tr key={i}>
              {i === 0 && <td className="left-bracket" rowSpan={n}></td>}
              <td style={{ color: '#fff' }}>
                {prefix}<sub>{i + 1}</sub>
              </td>
              {i === 0 && <td className="right-bracket" rowSpan={n}></td>}
            </tr>
          ))}
        </tbody>
      </table>
    );
    
    const ExpressionVector = ({ expressions }) => {
      const n = expressions.length;
      return (
        <table className="matrix">
          <tbody>
            {expressions.map((expr, i) => (
              <tr key={i}>
                {i === 0 && <td className="left-bracket" rowSpan={n}></td>}
                <td style={{ color: '#ccc' }}>
                  {expr}
                </td>
                {i === 0 && <td className="right-bracket" rowSpan={n}></td>}
              </tr>
            ))}
          </tbody>
        </table>
      );
    };
    
    // Compute symbolic expression for each row of Ax
    const computeAxExpressions = (A, n) => {
      const expressions = [];
      for (let i = 0; i < n; i++) {
        const terms = [];
        for (let j = 0; j < n; j++) {
          const coef = A[i][j];
          if (coef === 0) continue;
          const xSub = <span key={j}>x<sub>{j + 1}</sub></span>;
          if (coef === 1) {
            terms.push({ sign: '+', term: xSub });
          } else if (coef === -1) {
            terms.push({ sign: '-', term: xSub });
          } else if (coef > 0) {
            terms.push({ sign: '+', term: <span key={j}>{coef}x<sub>{j + 1}</sub></span> });
          } else {
            terms.push({ sign: '-', term: <span key={j}>{Math.abs(coef)}x<sub>{j + 1}</sub></span> });
          }
        }
        
        if (terms.length === 0) {
          expressions.push('0');
        } else {
          const result = [];
          terms.forEach((t, idx) => {
            if (idx === 0) {
              if (t.sign === '-') result.push('−');
              result.push(t.term);
            } else {
              result.push(t.sign === '+' ? ' + ' : ' − ');
              result.push(t.term);
            }
          });
          expressions.push(<span>{result}</span>);
        }
      }
      return expressions;
    };
    
    // Compute symbolic solution x = A⁻¹b (only for display when inverse exists)
    const computeSolutionExpressions = (invA, n) => {
      if (!invA) return null;
      const expressions = [];
      for (let i = 0; i < n; i++) {
        const terms = [];
        for (let j = 0; j < n; j++) {
          const coef = invA[i][j];
          if (Math.abs(coef) < 0.0001) continue;
          const bSub = <span key={j}>b<sub>{j + 1}</sub></span>;
          if (Math.abs(coef - 1) < 0.0001) {
            terms.push({ sign: '+', term: bSub });
          } else if (Math.abs(coef + 1) < 0.0001) {
            terms.push({ sign: '-', term: bSub });
          } else if (coef > 0) {
            const fracStr = toFraction(coef);
            terms.push({ sign: '+', term: <span key={j}>{fracStr}b<sub>{j + 1}</sub></span> });
          } else {
            const fracStr = toFraction(Math.abs(coef));
            terms.push({ sign: '-', term: <span key={j}>{fracStr}b<sub>{j + 1}</sub></span> });
          }
        }
        
        if (terms.length === 0) {
          expressions.push('0');
        } else {
          const result = [];
          terms.forEach((t, idx) => {
            if (idx === 0) {
              if (t.sign === '-') result.push('−');
              result.push(t.term);
            } else {
              result.push(t.sign === '+' ? ' + ' : ' − ');
              result.push(t.term);
            }
          });
          expressions.push(<span>{result}</span>);
        }
      }
      return expressions;
    };
    
    const Blackboard = ({ A, setA, dimension, det, isInvertible, invA, testX, setTestX, testB, setTestB, solution }) => {
      // Guard for dimension mismatch during transitions
      if (!A || A.length !== dimension || !A[0] || A[0].length !== dimension) {
        return <div style={{ background: '#0a0a0a', padding: '24px', color: '#666' }}>Loading...</div>;
      }
      
      const axExpressions = computeAxExpressions(A, dimension);
      const solutionExpressions = isInvertible ? computeSolutionExpressions(invA, dimension) : null;
      
      // For singular matrices
      const nullSpaceDim = !isInvertible ? nullity(A) : 0;
      const consistent = !isInvertible && testB ? isConsistent(A, testB) : false;
      
      const labelStyle = { 
        fontSize: '12px', 
        color: '#888', 
        fontFamily: 'Georgia, serif', 
        fontStyle: 'italic',
        textAlign: 'center',
        padding: '0 4px 4px 4px',
        verticalAlign: 'bottom'
      };
      
      const contentStyle = {
        verticalAlign: 'middle',
        padding: '0 4px'
      };
      
      const textStyle = {
        fontSize: '18px',
        color: '#fff',
        fontFamily: 'Georgia, serif',
        whiteSpace: 'nowrap'
      };
      
      // Input vector component for b
      const InputVector = ({ values, onChange, n }) => (
        <table className="matrix">
          <tbody>
            {Array.from({ length: n }, (_, i) => (
              <tr key={i}>
                {i === 0 && <td className="left-bracket" rowSpan={n}></td>}
                <td>
                  <input
                    type="number"
                    value={values[i] || 0}
                    onChange={(e) => {
                      const newVals = [...values];
                      newVals[i] = parseInt(e.target.value) || 0;
                      onChange(newVals);
                    }}
                  />
                </td>
                {i === 0 && <td className="right-bracket" rowSpan={n}></td>}
              </tr>
            ))}
          </tbody>
        </table>
      );
      
      // Display vector for computed result
      const DisplayVector = ({ values, n, status, statusColor }) => (
        <table className="matrix">
          <tbody>
            {Array.from({ length: n }, (_, i) => (
              <tr key={i}>
                {i === 0 && <td className="left-bracket" rowSpan={n}></td>}
                <td style={{ color: status ? statusColor : '#ccc' }}>
                  {status 
                    ? status
                    : (values && values[i] !== undefined 
                        ? toFraction(values[i])
                        : '—')}
                </td>
                {i === 0 && <td className="right-bracket" rowSpan={n}></td>}
              </tr>
            ))}
          </tbody>
        </table>
      );
      
      return (
        <div style={{
          background: '#0a0a0a',
          border: '1px solid #333',
          borderRadius: '4px',
          padding: '24px',
          marginBottom: '24px',
          overflowX: 'auto'
        }}>
          <table style={{ borderCollapse: 'collapse' }}>
            <tbody>
              {/* Row 1: Labels */}
              <tr>
                <td></td>{/* Ax = */}
                <td></td>{/* A */}
                <td></td>{/* x */}
                <td></td>{/* = */}
                <td style={labelStyle}>Comb of cols.</td>{/* Ax expressions */}
                <td></td>{/* = */}
                <td></td>{/* b */}
                <td style={{ width: '40px' }}></td>{/* spacer */}
                {isInvertible ? (
                  <>
                    <td style={labelStyle}>Solution</td>{/* x */}
                    <td></td>{/* = */}
                    <td></td>{/* solution expressions */}
                    <td style={{ width: '24px' }}></td>{/* spacer */}
                    <td></td>{/* x = */}
                    <td style={labelStyle}>A⁻¹</td>{/* inverse */}
                    <td></td>{/* b */}
                  </>
                ) : (
                  <>
                    <td colSpan={2} style={labelStyle}>{`Singular (nullity=${nullSpaceDim})`}</td>
                    <td colSpan={5}></td>
                  </>
                )}
                <td style={{ width: '40px' }}></td>{/* spacer */}
                <td colSpan={4} style={labelStyle}>Test for x</td>{/* label spanning A [x] = [b] */}
                <td style={{ width: '40px' }}></td>{/* spacer */}
                <td colSpan={4} style={labelStyle}>Test for b</td>{/* label spanning b = [b] → x = [x] */}
              </tr>
              
              {/* Row 2: Content */}
              <tr>
                <td style={contentStyle}><span style={textStyle}>Ax =</span></td>
                <td style={contentStyle}><MatrixInput matrix={A} onChange={setA} /></td>
                <td style={contentStyle}><SymbolicVector prefix="x" n={dimension} /></td>
                <td style={contentStyle}><span style={textStyle}>=</span></td>
                <td style={contentStyle}><ExpressionVector expressions={axExpressions} /></td>
                <td style={contentStyle}><span style={textStyle}>=</span></td>
                <td style={contentStyle}><SymbolicVector prefix="b" n={dimension} /></td>
                <td></td>{/* spacer */}
                
                {isInvertible && solutionExpressions ? (
                  <>
                    <td style={contentStyle}><SymbolicVector prefix="x" n={dimension} /></td>
                    <td style={contentStyle}><span style={textStyle}>=</span></td>
                    <td style={contentStyle}><ExpressionVector expressions={solutionExpressions} /></td>
                    <td></td>{/* spacer */}
                    <td style={contentStyle}><span style={textStyle}>x =</span></td>
                    <td style={contentStyle}><MatrixDisplay matrix={invA} /></td>
                    <td style={contentStyle}><SymbolicVector prefix="b" n={dimension} /></td>
                  </>
                ) : (
                  <>
                    <td colSpan={2} style={{ ...contentStyle, color: '#888', fontFamily: 'Georgia, serif', fontSize: '14px', whiteSpace: 'nowrap' }}>
                      No A⁻¹
                    </td>
                    <td colSpan={5} style={{ ...contentStyle, color: '#888', fontFamily: 'Georgia, serif', fontSize: '13px', whiteSpace: 'nowrap' }}>
                      (0, 1, or ∞ solutions depending on b)
                    </td>
                  </>
                )}
                
                <td></td>{/* spacer */}
                <td style={contentStyle}><span style={textStyle}>A</span></td>
                <td style={contentStyle}><InputVector values={testX} onChange={setTestX} n={dimension} /></td>
                <td style={contentStyle}><span style={textStyle}>=</span></td>
                <td style={contentStyle}>
                  <DisplayVector values={matrixVectorMultiply(A, testX)} n={dimension} />
                </td>
                <td></td>{/* spacer */}
                <td style={contentStyle}><span style={textStyle}>b =</span></td>
                <td style={contentStyle}><InputVector values={testB} onChange={setTestB} n={dimension} /></td>
                <td style={contentStyle}><span style={textStyle}>→ x =</span></td>
                <td style={contentStyle}>
                  {isInvertible ? (
                    <DisplayVector values={solution} n={dimension} />
                  ) : (
                    <DisplayVector values={null} n={dimension} status={consistent ? '∞' : '∅'} statusColor={consistent ? '#88f' : '#f66'} />
                  )}
                </td>
              </tr>
              
              {/* Row 3: Bottom labels */}
              <tr>
                <td></td>{/* Ax = */}
                <td></td>{/* A */}
                <td></td>{/* x */}
                <td></td>{/* = */}
                <td></td>{/* Ax expressions */}
                <td></td>{/* = */}
                <td></td>{/* b */}
                <td></td>{/* spacer */}
                {isInvertible ? (
                  <>
                    <td></td>{/* x */}
                    <td></td>{/* = */}
                    <td></td>{/* solution expressions */}
                    <td></td>{/* spacer */}
                    <td></td>{/* x = */}
                    <td></td>{/* inverse */}
                    <td></td>{/* b */}
                  </>
                ) : (
                  <>
                    <td colSpan={2}></td>
                    <td colSpan={5}></td>
                  </>
                )}
                <td></td>{/* spacer */}
                <td></td>{/* A */}
                <td style={labelStyle}>x</td>{/* x input label */}
                <td></td>{/* = */}
                <td style={labelStyle}>b</td>{/* b output label */}
                <td></td>{/* spacer */}
                <td></td>{/* b = */}
                <td style={labelStyle}>b</td>{/* b input label */}
                <td></td>{/* → x = */}
                <td style={labelStyle}>x</td>{/* x output label */}
              </tr>
            </tbody>
          </table>
        </div>
      );
    };

    // ============== 2D VISUALIZATION ==============
    
    const Visualization2D = ({ A, b, x, solution, isInvertible, rowPicture, colPicture }) => {
      const canvasRef = useRef(null);
      
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        // Guard: make sure A is 2x2
        if (!A || A.length !== 2 || !A[0] || A[0].length !== 2) return;
        if (!b || b.length !== 2) return;
        
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const scale = 40;
        
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, w, h);
        
        // Grid
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        for (let i = -10; i <= 10; i++) {
          ctx.beginPath();
          ctx.moveTo(cx + i * scale, 0);
          ctx.lineTo(cx + i * scale, h);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, cy + i * scale);
          ctx.lineTo(w, cy + i * scale);
          ctx.stroke();
        }
        
        // Axes
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, cy);
        ctx.lineTo(w, cy);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx, 0);
        ctx.lineTo(cx, h);
        ctx.stroke();
        
        const drawArrow = (x1, y1, x2, y2, color, width = 2) => {
          const headLen = 10;
          const dx = x2 - x1;
          const dy = y2 - y1;
          const angle = Math.atan2(dy, dx);
          
          ctx.strokeStyle = color;
          ctx.fillStyle = color;
          ctx.lineWidth = width;
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(x2, y2);
          ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6));
          ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6));
          ctx.closePath();
          ctx.fill();
        };
        
        const toScreen = (vx, vy) => [cx + vx * scale, cy - vy * scale];
        
        // Row picture: draw lines for each row equation
        if (rowPicture) {
          const colors = ['#cc6666', '#66cc66'];
          for (let i = 0; i < 2; i++) {
            const a = A[i][0];
            const bCoef = A[i][1];
            const c = b[i];
            
            // Line: a*x + b*y = c
            ctx.strokeStyle = colors[i];
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            if (Math.abs(bCoef) > 0.001) {
              // y = (c - a*x) / b
              const x1 = -10, x2 = 10;
              const y1 = (c - a * x1) / bCoef;
              const y2 = (c - a * x2) / bCoef;
              const [sx1, sy1] = toScreen(x1, y1);
              const [sx2, sy2] = toScreen(x2, y2);
              ctx.moveTo(sx1, sy1);
              ctx.lineTo(sx2, sy2);
            } else if (Math.abs(a) > 0.001) {
              // Vertical line x = c/a
              const xVal = c / a;
              const [sx, sy1] = toScreen(xVal, -10);
              const [, sy2] = toScreen(xVal, 10);
              ctx.moveTo(sx, sy1);
              ctx.lineTo(sx, sy2);
            }
            ctx.stroke();
          }
          
          // Draw solution point at intersection
          if (solution) {
            const [sx, sy] = toScreen(solution[0], solution[1]);
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(sx, sy, 6, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Column picture: draw column vectors and parallelogram
        if (colPicture) {
          const col1 = getColumn(A, 0);
          const col2 = getColumn(A, 1);
          
          // If solution exists, show the parallelogram
          if (solution) {
            const scaled1 = scaleVector(col1, solution[0]);
            const scaled2 = scaleVector(col2, solution[1]);
            
            const [s1x, s1y] = toScreen(scaled1[0], scaled1[1]);
            const [s2x, s2y] = toScreen(scaled2[0], scaled2[1]);
            const [bx, by] = toScreen(b[0], b[1]);
            
            // Draw dashed lines to complete parallelogram
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            
            // From tip of scaled1 to b
            ctx.beginPath();
            ctx.moveTo(s1x, s1y);
            ctx.lineTo(bx, by);
            ctx.stroke();
            
            // From tip of scaled2 to b
            ctx.beginPath();
            ctx.moveTo(s2x, s2y);
            ctx.lineTo(bx, by);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // x₁·col₁ from origin (red)
            drawArrow(cx, cy, s1x, s1y, '#cc6666', 2);
            
            // x₂·col₂ from origin (green)
            drawArrow(cx, cy, s2x, s2y, '#66cc66', 2);
            
            // Target b (white filled circle)
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(bx, by, 6, 0, Math.PI * 2);
            ctx.fill();
          } else {
            // No solution - just show column vectors from origin
            drawArrow(cx, cy, ...toScreen(col1[0], col1[1]), '#cc6666', 2);
            drawArrow(cx, cy, ...toScreen(col2[0], col2[1]), '#66cc66', 2);
            
            // Target b
            const [bx, by] = toScreen(b[0], b[1]);
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(bx, by, 6, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
      }, [A, b, x, solution, isInvertible, rowPicture, colPicture]);
      
      return (
        <canvas
          ref={canvasRef}
          width={450}
          height={450}
          style={{ border: '1px solid #333' }}
        />
      );
    };

    // ============== 3D VISUALIZATION ==============
    
    const Visualization3D = ({ A, b, x, solution, isInvertible, rowPicture, colPicture }) => {
      const containerRef = useRef(null);
      const sceneRef = useRef(null);
      const rendererRef = useRef(null);
      const objectsRef = useRef([]);
      const animationRef = useRef(null);
      
      useEffect(() => {
        if (!containerRef.current) return;
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        sceneRef.current = scene;
        
        const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
        camera.up.set(0, 0, 1); // Z is up
        camera.position.set(8, -8, 6);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(450, 450);
        containerRef.current.appendChild(renderer.domElement);
        rendererRef.current = renderer;
        
        // Grid on XY plane (Z is up)
        const grid = new THREE.GridHelper(10, 10, 0x333333, 0x222222);
        grid.rotation.x = Math.PI / 2; // Rotate to lie on XY plane
        scene.add(grid);
        
        // Axes
        const axesLength = 5;
        const addAxis = (start, end, color) => {
          const geom = new THREE.BufferGeometry().setFromPoints([start, end]);
          scene.add(new THREE.Line(geom, new THREE.LineBasicMaterial({ color })));
        };
        addAxis(new THREE.Vector3(-axesLength, 0, 0), new THREE.Vector3(axesLength, 0, 0), 0x444444);
        addAxis(new THREE.Vector3(0, -axesLength, 0), new THREE.Vector3(0, axesLength, 0), 0x444444);
        addAxis(new THREE.Vector3(0, 0, -axesLength), new THREE.Vector3(0, 0, axesLength), 0x444444);
        
        // Axis labels
        const createLabel = (text, position) => {
          const canvas = document.createElement('canvas');
          canvas.width = 64;
          canvas.height = 64;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#666666';
          ctx.font = '48px monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(text, 32, 32);
          const texture = new THREE.CanvasTexture(canvas);
          const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.position.copy(position);
          sprite.scale.set(0.5, 0.5, 1);
          return sprite;
        };
        scene.add(createLabel('X', new THREE.Vector3(5.5, 0, 0)));
        scene.add(createLabel('Y', new THREE.Vector3(0, 5.5, 0)));
        scene.add(createLabel('Z', new THREE.Vector3(0, 0, 5.5)));
        
        let angle = 0;
        const animate = () => {
          animationRef.current = requestAnimationFrame(animate);
          angle += 0.003;
          const radius = 12;
          const height = 6;
          camera.position.x = radius * Math.cos(angle);
          camera.position.y = radius * Math.sin(angle);
          camera.position.z = height;
          camera.lookAt(0, 0, 0);
          renderer.render(scene, camera);
        };
        animate();
        
        return () => {
          cancelAnimationFrame(animationRef.current);
          renderer.dispose();
          if (containerRef.current && renderer.domElement) {
            containerRef.current.removeChild(renderer.domElement);
          }
        };
      }, []);
      
      // Update objects
      useEffect(() => {
        if (!sceneRef.current) return;
        const scene = sceneRef.current;
        
        // Guard: make sure A is 3x3
        if (!A || A.length !== 3 || !A[0] || A[0].length !== 3) return;
        if (!b || b.length !== 3) return;
        
        objectsRef.current.forEach(obj => scene.remove(obj));
        objectsRef.current = [];
        
        const addArrow = (v, color) => {
          const dir = new THREE.Vector3(v[0], v[1], v[2]);
          const len = dir.length();
          if (len < 0.001) return;
          dir.normalize();
          const arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(0, 0, 0), len, color, 0.2, 0.1);
          scene.add(arrow);
          objectsRef.current.push(arrow);
        };
        
        const addPlane = (normal, d, color) => {
          const n = new THREE.Vector3(normal[0], normal[1], normal[2]);
          if (n.length() < 0.001) return;
          n.normalize();
          
          const plane = new THREE.PlaneGeometry(10, 10);
          const material = new THREE.MeshBasicMaterial({
            color,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide,
            depthWrite: false
          });
          const mesh = new THREE.Mesh(plane, material);
          
          // Orient plane to normal
          mesh.lookAt(n);
          // Position plane at distance d from origin along normal
          const offset = n.clone().multiplyScalar(d / n.dot(n));
          mesh.position.copy(offset);
          
          scene.add(mesh);
          objectsRef.current.push(mesh);
        };
        
        // Column picture
        if (colPicture) {
          // Solution parallelepiped if exists
          if (solution) {
            const col1 = getColumn(A, 0);
            const col2 = getColumn(A, 1);
            const col3 = getColumn(A, 2);
            
            const s1 = scaleVector(col1, solution[0]);
            const s2 = scaleVector(col2, solution[1]);
            const s3 = scaleVector(col3, solution[2]);
            
            // Create parallelepiped with proper vertex calculations
            const createParallelepiped = (v1, v2, v3, edgeColors) => {
              const o = new THREE.Vector3(0, 0, 0);
              const a = new THREE.Vector3(v1[0], v1[1], v1[2]);
              const b = new THREE.Vector3(v2[0], v2[1], v2[2]);
              const c = new THREE.Vector3(v3[0], v3[1], v3[2]);
              const ab = a.clone().add(b);
              const ac = a.clone().add(c);
              const bc = b.clone().add(c);
              const abc = a.clone().add(b).add(c);
              
              // 12 edges grouped: 3 from origin (colored), 9 completing the box (gray dashed)
              const edgesFromOrigin = [[o, a], [o, b], [o, c]];
              const edgesCompletion = [
                [a, ab], [a, ac],
                [b, ab], [b, bc],
                [c, ac], [c, bc],
                [ab, abc], [ac, abc], [bc, abc]
              ];
              
              // Draw colored edges from origin
              edgesFromOrigin.forEach(([start, end], i) => {
                const geom = new THREE.BufferGeometry().setFromPoints([start, end]);
                const mat = new THREE.LineBasicMaterial({ color: edgeColors[i], linewidth: 2 });
                const line = new THREE.Line(geom, mat);
                scene.add(line);
                objectsRef.current.push(line);
              });
              
              // Draw dashed gray edges completing the box
              edgesCompletion.forEach(([start, end]) => {
                const geom = new THREE.BufferGeometry().setFromPoints([start, end]);
                const mat = new THREE.LineDashedMaterial({ color: 0x666666, dashSize: 0.2, gapSize: 0.1 });
                const line = new THREE.Line(geom, mat);
                line.computeLineDistances();
                scene.add(line);
                objectsRef.current.push(line);
              });
            };
            
            createParallelepiped(s1, s2, s3, [0xcc6666, 0x66cc66, 0x6666cc]);
          } else {
            // No solution - just show column vectors as arrows
            addArrow(getColumn(A, 0), 0xcc6666);
            addArrow(getColumn(A, 1), 0x66cc66);
            addArrow(getColumn(A, 2), 0x6666cc);
          }
        }
        
        // Row picture - show planes
        if (rowPicture) {
          const planeColors = [0x664444, 0x446644, 0x444466];
          for (let i = 0; i < 3; i++) {
            addPlane(A[i], b[i], planeColors[i]);
          }
        }
        
      }, [A, b, solution, rowPicture, colPicture]);
      
      return (
        <div
          ref={containerRef}
          style={{ border: '1px solid #333', width: '450px', height: '450px' }}
        />
      );
    };

    // ============== MAIN APP ==============
    
    function App() {
      const [dimension, setDimension] = useState(3);
      const [A, setA] = useState(createIdentityMatrix(3));
      const [testX, setTestX] = useState([1, 1, 1]);
      const [testB, setTestB] = useState([1, 1, 1]);
      const [rowPicture, setRowPicture] = useState(false);
      const [colPicture, setColPicture] = useState(true);
      
      // Update A and test vectors when dimension changes
      useEffect(() => {
        setA(createIdentityMatrix(dimension));
        setTestX(Array(dimension).fill(1));
        setTestB(Array(dimension).fill(1));
      }, [dimension]);
      
      // Sync testB with computed Ax when A or testX changes
      useEffect(() => {
        if (A && testX && A.length === testX.length) {
          const computedB = matrixVectorMultiply(A, testX);
          setTestB(computedB);
        }
      }, [A, testX]);
      
      const det = useMemo(() => {
        if (!A || A.length === 0) return 0;
        return determinant(A);
      }, [A]);
      const isInvertible = Math.abs(det) > 1e-10;
      const invA = useMemo(() => {
        if (!A || A.length === 0) return null;
        return inverse(A);
      }, [A]);
      const solution = useMemo(() => {
        if (!invA || !testB || invA.length !== testB.length) return null;
        return matrixVectorMultiply(invA, testB);
      }, [invA, testB]);
      
      
      return (
        <div style={{ padding: '24px', maxWidth: '1200px', margin: '0 auto' }}>
          <h1 style={{ 
            fontSize: '16px', 
            fontWeight: 'normal', 
            color: '#666',
            marginBottom: '24px',
            letterSpacing: '0.5px'
          }}>
            Linear Algebra — 18.06
          </h1>
          
          <DimensionSelector value={dimension} onChange={setDimension} />
          
          <PictureToggle
            rowPicture={rowPicture}
            colPicture={colPicture}
            onRowChange={setRowPicture}
            onColChange={setColPicture}
          />
          
          {/* Blackboard: Equation Display */}
          <Blackboard 
            A={A} 
            setA={setA} 
            dimension={dimension} 
            det={det} 
            isInvertible={isInvertible} 
            invA={invA}
            testX={testX}
            setTestX={setTestX}
            testB={testB}
            setTestB={setTestB}
            solution={solution}
          />
          
          {/* Visualization + Determinant Panel */}
          {dimension <= 3 && A && A.length === dimension && testB && testB.length === dimension ? (
            <div style={{ display: 'flex', gap: '24px', alignItems: 'flex-start' }}>
              <div>
                <div style={{ fontSize: '10px', color: '#666', marginBottom: '8px', fontFamily: 'monospace' }}>
                  VISUALIZATION
                </div>
                {dimension === 2 ? (
                  <Visualization2D
                    A={A}
                    b={testB}
                    x={solution}
                    solution={solution}
                    isInvertible={isInvertible}
                    rowPicture={rowPicture}
                    colPicture={colPicture}
                  />
                ) : dimension === 3 ? (
                  <Visualization3D
                    A={A}
                    b={testB}
                    x={solution}
                    solution={solution}
                    isInvertible={isInvertible}
                    rowPicture={rowPicture}
                    colPicture={colPicture}
                  />
                ) : null}
              </div>
              
              {/* Determinant Panel */}
              <div style={{
                background: '#1a1a1a',
                border: '1px solid #333',
                padding: '20px',
                minWidth: '200px',
                fontFamily: 'monospace',
                fontSize: '13px'
              }}>
                <div style={{ fontSize: '10px', color: '#666', marginBottom: '16px', fontFamily: 'monospace' }}>
                  DETERMINANT
                </div>
                
                <div style={{ marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid #333' }}>
                  <div style={{ color: '#666', marginBottom: '4px', fontSize: '11px' }}>det(A)</div>
                  <div style={{ 
                    fontSize: '24px', 
                    color: det < 0 ? '#ff6666' : (Math.abs(det) < 1e-10 ? '#666' : '#fff'),
                    fontFamily: 'Georgia, serif'
                  }}>
                    {toFraction(det)}
                  </div>
                  {det < 0 && (
                    <div style={{ color: '#ff6666', fontSize: '10px', marginTop: '4px' }}>
                      orientation flipped
                    </div>
                  )}
                </div>
                
                <div style={{ marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid #333' }}>
                  <div style={{ color: '#666', marginBottom: '4px', fontSize: '11px' }}>
                    |det(A)| = {dimension === 2 ? 'Area' : 'Volume'}
                  </div>
                  <div style={{ fontSize: '18px', color: '#fff' }}>
                    {toFraction(Math.abs(det))}
                  </div>
                </div>
                
                <div style={{ marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid #333' }}>
                  <div style={{ color: '#666', marginBottom: '4px', fontSize: '11px' }}>Rank</div>
                  <div style={{ fontSize: '18px', color: '#fff' }}>
                    {rank(A)}
                  </div>
                </div>
                
                <div style={{ marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid #333' }}>
                  <div style={{ color: '#666', marginBottom: '4px', fontSize: '11px' }}>Nullity</div>
                  <div style={{ fontSize: '18px', color: '#fff' }}>
                    {dimension - rank(A)}
                  </div>
                </div>
                
                <div>
                  <div style={{ color: '#666', marginBottom: '4px', fontSize: '11px' }}>Invertible?</div>
                  <div style={{ 
                    fontSize: '14px', 
                    color: isInvertible ? '#66cc66' : '#ff6666',
                    fontWeight: 'bold'
                  }}>
                    {isInvertible ? 'YES' : 'NO'}
                  </div>
                </div>
              </div>
            </div>
          ) : dimension > 3 ? (
            <div style={{ display: 'flex', gap: '24px', alignItems: 'flex-start' }}>
              <div style={{
                background: '#1a1a1a',
                border: '1px solid #333',
                padding: '24px',
                fontFamily: 'monospace',
                fontSize: '13px',
                color: '#666'
              }}>
                Visualization not available for ℝ<sup>{dimension}</sup> — algebra tools above still work
              </div>
              
              {/* Determinant Panel for higher dimensions */}
              <div style={{
                background: '#1a1a1a',
                border: '1px solid #333',
                padding: '20px',
                minWidth: '200px',
                fontFamily: 'monospace',
                fontSize: '13px'
              }}>
                <div style={{ fontSize: '10px', color: '#666', marginBottom: '16px', fontFamily: 'monospace' }}>
                  DETERMINANT
                </div>
                
                <div style={{ marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid #333' }}>
                  <div style={{ color: '#666', marginBottom: '4px', fontSize: '11px' }}>det(A)</div>
                  <div style={{ 
                    fontSize: '24px', 
                    color: det < 0 ? '#ff6666' : (Math.abs(det) < 1e-10 ? '#666' : '#fff'),
                    fontFamily: 'Georgia, serif'
                  }}>
                    {toFraction(det)}
                  </div>
                  {det < 0 && (
                    <div style={{ color: '#ff6666', fontSize: '10px', marginTop: '4px' }}>
                      orientation flipped
                    </div>
                  )}
                </div>
                
                <div style={{ marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid #333' }}>
                  <div style={{ color: '#666', marginBottom: '4px', fontSize: '11px' }}>Rank</div>
                  <div style={{ fontSize: '18px', color: '#fff' }}>
                    {rank(A)}
                  </div>
                </div>
                
                <div style={{ marginBottom: '16px', paddingBottom: '16px', borderBottom: '1px solid #333' }}>
                  <div style={{ color: '#666', marginBottom: '4px', fontSize: '11px' }}>Nullity</div>
                  <div style={{ fontSize: '18px', color: '#fff' }}>
                    {dimension - rank(A)}
                  </div>
                </div>
                
                <div>
                  <div style={{ color: '#666', marginBottom: '4px', fontSize: '11px' }}>Invertible?</div>
                  <div style={{ 
                    fontSize: '14px', 
                    color: isInvertible ? '#66cc66' : '#ff6666',
                    fontWeight: 'bold'
                  }}>
                    {isInvertible ? 'YES' : 'NO'}
                  </div>
                </div>
              </div>
            </div>
          ) : null}
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
